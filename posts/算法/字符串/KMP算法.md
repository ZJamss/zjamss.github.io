* **背景**
  KMP算法一种改进的模式匹配算法，是D.E.Knuth、V.R.Pratt、J.H.Morris于1977年联合发表，KMP算法又称克努特-莫里斯-普拉特操作。它的改进在于：每当从某个起始位置开始一趟比较后，在匹配过程中出现失配，不回溯i，而是利用已经得到的部分匹配结果，将一种假想的位置定位“指针”在模式上向右滑动尽可能远的一段距离到某个位置后，继续按规则进行下一次的比较。
* **算法流程**
  规定i是主串S的下标，j是模式T的下标。现在假设现在主串S匹配到 i 位置，模式串T匹配到 j 位置。

如果j = -1，则i++，j++，继续匹配下一个字符；
如果S[i] = T[j]，则i++，j++，继续匹配下一个字符；
如果j != -1，且S[i] != P[j]，则 i 不变，j = next[j]。此举意味着失配时，接下来模式串T要相对于主串S向右移动j - next [j] 位。


```java
int KMP(int start,char S[],char T[])
{
	int i=start,j=0;
	while(S[i]!='\0'&&T[j]!='\0')
	{
		if(j==-1||S[i]==T[j])
		{
			i++;         //继续对下一个字符比较 
			j++;         //模式串向右滑动 
		}
		else j=next[j];
	}
	if(T[j]=='\0') return (i-j);    //匹配成功返回下标 
	else return -1;                 //匹配失败返回-1 
}
```

### 疑问？

**next是什么？？？它是怎么来的？？？**

* 首先我们来解释一个名词：最长公共前后缀。
* 假设有一个串P=“p0p1p2 … pj-1 pj ”。如果存在p0 p1 …pk-1 pk = pj-k pj-k+1  … pj-1 pj ，我们就说在P串中有一个最大长度为k+1的公共前后缀。

**如何寻找前后缀？**

* 找前缀时，要找除了最后一个字符的所有子串。
* 找后缀时，要找除了第一个字符的所有子串。

假如现有串P=abaabca,其最大公共前后缀长度为

![](file://C:\Users\17419\Documents\IkMarkdown\.assets\KMP算法.md2514.0891139.png)
